require 'pty'
require 'expect'

require_relative "MediaFile.rb"
require_relative 'MyLogger.rb'

class ConvertJob
  
  attr_accessor :media_file
  attr_accessor :syscall
  attr_accessor :output
  attr_accessor :exit_code
  attr_accessor :converter_pid
  
  def initialize(media_file)
    raise "MediaFile not defined" unless media_file
    
    @media_file = media_file
    
    #do we really need output? would be packed full of the frame updates
    #exit code might be enough, along with any exception messages
    @output = ""
  end
  
  def set_syscall(syscall)
    @syscall = syscall
  end
  
  def run
    #execute syscall here
    #file is MediaFile
    
    raise "Syscall not defined" unless @syscall
    raise "MediaFile not defined" unless @media_file

    MyLogger.instance.info("ConvertJob", "Running ConvertJob for #{@media_file.path}")

    #inital status. everything is PROCESS until started
    @media_file.set_status("PROCESS")
    
    begin      
      #continuously read from stdout to get current converted framecount and fps. 
      
      #TODO: possibly modify num_threads if fps breaks threshold
      
      PTY.spawn( @syscall ) do |stdout, stdin, pid|
      
        begin
          #MyLogger.instance.info("ConvertJob", "Received pid #{pid} for conversion of #{@media_file.path}")
          
          puts "Got pid #{pid}"
          
          puts "Waiting for ctrl-c prompt"
          
          #TODO: updated ffmpeg seems to not have this
          #stdout.expect(/Press ctrl-c to stop encoding/, 10) do
            #nothing, skip the data ffmpeg prints before starting conversion
          #end
          
          #TODO: !!! syscall outputs to file. this reads that file
          
          
          
          
          
          
          
          
          puts "Waiting for 'frame=' Encoding started"
          
          while(!stdout.closed? && !stdin.closed?)
            #TODO: need a non-blocking way to read stdout. otherwise the main thread locks up
              
            #TODO: why sleep here?
            sleep 4
            
            #puts "stdout read"
            
            #stdout.each { |line| puts "Got line: #{line}" }
          
            #puts "stdout read done"
            
            #modern ffmpeg doesn't need this
            #grab the next result            
            #stdin.puts("\r")
              

            
            puts "Raw stdout gets: #{result}"
            puts "Processing pty result"
            
            stdout.expect(/^frame=/, 3) do |result|

              #found frameinfo ["28946 fps=  2 q=28.0 size=  198817kB time=1205.20 bitrate=1351.4kbits/s    \r\e[0m\e[0;39mframe="]
              
              #found something new
              
              puts "frameinfo result #{result}"
              if(result)
                fields = result[0].split("\s")
                converted_frames = fields[0]
                framerate = fields[2]
                
                if(converted_frames =~ /\d+/)
                  @media_file.update_converted_frame_count(converted_frames)
                  @media_file.update_framerate(framerate)
                else
                  #likely the first iteration
                  @media_file.update_converted_frame_count(0)
                  @media_file.update_framerate(0)
                end
                
                puts "found frameinfo #{result}\nconverted: #{converted_frames}/#{@media_file.get_total_frame_count}\nrate: #{framerate}"
              end         
            end
            
            #sleep? the process is running, don't have to keep hammering it with /r
            #make sure the right thing is sleeping 
            #set interval in ConvertJobFactory  
            #sleep @checkup_sleep        
            
          end
          
          puts "stdout of syscall closed"
          
        rescue Errno::EIO => e
          MyLogger.instance.debug("ConvertJob", "Errno:EIO error, but this probably just means that the process has finished giving output #{e.message}")
        rescue => e

          MyLogger.instance.error("ConvertJob", "ConvertJob for #{@media_file.path} failed with #{e.message}")       
          #file status to shit
          @media_file.set_status("FAILED: #{e}")
        ensure
          MyLogger.instance.info("ConvertJob", "Waiting for pid: #{pid} to exit") 
          Process.wait(pid)  
        end 
        
      end
      
      
      
      
    end

    @exit_code = $?
     
    #update file status to done
    if( @exit_code == 0 )
      @media_file.set_status("DONE")
    else
      @media_file.set_message(status)
      @media_file.set_status("FAILED")      
    end   
    
    MyLogger.instance.info("ConvertJob", "Conversion exits with status: #{status}") 
  end
end